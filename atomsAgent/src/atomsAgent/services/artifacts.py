"""
Artifact Generation and Management

Handles detection, storage, and rendering of artifacts generated by Claude.
Supports multiple artifact types: code, markdown, diagrams, etc.
"""

from __future__ import annotations

import re
import uuid
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Literal

ArtifactType = Literal["code", "markdown", "diagram", "html", "svg", "json", "text"]


@dataclass
class Artifact:
    """Represents an artifact generated by Claude"""
    
    id: str
    type: ArtifactType
    title: str
    content: str
    language: str | None = None  # For code artifacts
    created_at: datetime | None = None
    metadata: dict[str, Any] | None = None
    
    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for storage"""
        return {
            "id": self.id,
            "type": self.type,
            "title": self.title,
            "content": self.content,
            "language": self.language,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "metadata": self.metadata or {}
        }
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Artifact:
        """Create from dictionary"""
        created_at = data.get("created_at")
        if created_at and isinstance(created_at, str):
            created_at = datetime.fromisoformat(created_at)
        
        return cls(
            id=data["id"],
            type=data["type"],
            title=data["title"],
            content=data["content"],
            language=data.get("language"),
            created_at=created_at,
            metadata=data.get("metadata")
        )


class ArtifactDetector:
    """Detects artifacts in Claude responses"""
    
    # Patterns for detecting different artifact types
    CODE_BLOCK_PATTERN = r"```(\w+)?\n(.*?)\n```"
    ARTIFACT_TAG_PATTERN = r"<artifact\s+type=['\"](\w+)['\"](?:\s+title=['\"]([^'\"]+)['\"])?>(.*?)</artifact>"
    
    @classmethod
    def detect_artifacts(cls, text: str) -> list[Artifact]:
        """
        Detect artifacts in Claude's response text.
        
        Args:
            text: Response text from Claude
        
        Returns:
            List of detected artifacts
        """
        artifacts: list[Artifact] = []
        
        # Method 1: Detect explicit artifact tags
        artifact_matches = re.finditer(cls.ARTIFACT_TAG_PATTERN, text, re.DOTALL)
        for match in artifact_matches:
            artifact_type = match.group(1)
            title = match.group(2) or "Untitled Artifact"
            content = match.group(3).strip()
            
            artifact = Artifact(
                id=str(uuid.uuid4()),
                type=artifact_type,  # type: ignore
                title=title,
                content=content,
                created_at=datetime.now()
            )
            artifacts.append(artifact)
        
        # Method 2: Detect code blocks
        code_matches = re.finditer(cls.CODE_BLOCK_PATTERN, text, re.DOTALL)
        for match in code_matches:
            language = match.group(1) or "text"
            content = match.group(2).strip()
            
            # Skip if already detected as artifact tag
            if any(a.content == content for a in artifacts):
                continue
            
            artifact = Artifact(
                id=str(uuid.uuid4()),
                type="code",
                title=f"{language.capitalize()} Code",
                content=content,
                language=language,
                created_at=datetime.now()
            )
            artifacts.append(artifact)
        
        return artifacts
    
    @classmethod
    def extract_artifact_metadata(cls, artifact: Artifact) -> dict[str, Any]:
        """
        Extract metadata from artifact content.
        
        Args:
            artifact: Artifact to analyze
        
        Returns:
            Metadata dictionary
        """
        metadata: dict[str, Any] = {}
        
        if artifact.type == "code":
            # Extract code metadata
            lines = artifact.content.split("\n")
            metadata["line_count"] = len(lines)
            metadata["char_count"] = len(artifact.content)
            
            # Detect imports/dependencies
            if artifact.language in ("python", "py"):
                imports = [line for line in lines if line.strip().startswith(("import ", "from "))]
                metadata["imports"] = imports
            elif artifact.language in ("javascript", "js", "typescript", "ts"):
                imports = [line for line in lines if "import " in line or "require(" in line]
                metadata["imports"] = imports
        
        elif artifact.type == "markdown":
            # Extract markdown metadata
            lines = artifact.content.split("\n")
            headers = [line for line in lines if line.strip().startswith("#")]
            metadata["headers"] = headers
            metadata["line_count"] = len(lines)
        
        return metadata


class ArtifactStorage:
    """Handles storage and retrieval of artifacts"""
    
    def __init__(self, supabase_client: Any = None):
        """
        Initialize artifact storage.
        
        Args:
            supabase_client: Optional Supabase client for database storage
        """
        self.supabase = supabase_client
        self._memory_store: dict[str, Artifact] = {}
    
    async def store_artifact(
        self,
        artifact: Artifact,
        session_id: str,
        message_id: str | None = None
    ) -> str:
        """
        Store an artifact.
        
        Args:
            artifact: Artifact to store
            session_id: Session ID
            message_id: Optional message ID
        
        Returns:
            Artifact ID
        """
        # Add metadata
        if artifact.metadata is None:
            artifact.metadata = {}
        artifact.metadata["session_id"] = session_id
        if message_id:
            artifact.metadata["message_id"] = message_id
        
        # Store in database if available
        if self.supabase:
            try:
                self.supabase.table("artifacts").insert({
                    "id": artifact.id,
                    "type": artifact.type,
                    "title": artifact.title,
                    "content": artifact.content,
                    "language": artifact.language,
                    "session_id": session_id,
                    "message_id": message_id,
                    "metadata": artifact.metadata,
                    "created_at": artifact.created_at.isoformat() if artifact.created_at else None
                }).execute()
            except Exception as e:
                print(f"Error storing artifact in database: {e}")
                # Fall back to memory storage
                self._memory_store[artifact.id] = artifact
        else:
            # Store in memory
            self._memory_store[artifact.id] = artifact
        
        return artifact.id
    
    async def get_artifact(self, artifact_id: str) -> Artifact | None:
        """
        Retrieve an artifact by ID.
        
        Args:
            artifact_id: Artifact ID
        
        Returns:
            Artifact or None if not found
        """
        # Try database first
        if self.supabase:
            try:
                result = self.supabase.table("artifacts").select("*").eq("id", artifact_id).execute()
                if result.data:
                    return Artifact.from_dict(result.data[0])
            except Exception as e:
                print(f"Error retrieving artifact from database: {e}")
        
        # Fall back to memory
        return self._memory_store.get(artifact_id)
    
    async def get_session_artifacts(self, session_id: str) -> list[Artifact]:
        """
        Get all artifacts for a session.
        
        Args:
            session_id: Session ID
        
        Returns:
            List of artifacts
        """
        artifacts: list[Artifact] = []
        
        # Try database first
        if self.supabase:
            try:
                result = self.supabase.table("artifacts").select("*").eq("session_id", session_id).execute()
                artifacts = [Artifact.from_dict(data) for data in result.data]
                return artifacts
            except Exception as e:
                print(f"Error retrieving session artifacts from database: {e}")
        
        # Fall back to memory
        artifacts = [a for a in self._memory_store.values() if a.metadata and a.metadata.get("session_id") == session_id]
        return artifacts
